File:
    vocabulary=Vocabulary
    theory=Theory
;

Vocabulary:
'vocabulary' '{' (declarations=Declaration)* '}'
;

Theory:
'theory' '{' ((constraints=Expression '.')*  definitions=Definition*)* '}'
;

Comment:
  /\/\/.*$/
;

Expression: Quantification;

Quantification: AQuantification | Conjunction;
Conjunction: AConjunction | Disjunction;
Disjunction: ADisjunction | Implication;
Implication: AImplication | RImplication;
RImplication: ARImplication | Equivalence;
Equivalence: AEquivalence | Comparison;
Comparison: AComparison | SumMinus;
SumMinus: ASumMinus | MultDiv;
MultDiv: AMultDiv | Unary;
Unary: AUnary | Aggregate;
Aggregate: AAggregate | Base;


AAggregate: aggtype=AggType set=SetExp;
AQuantification: q=Quantor (vars=ID '[' sorts=Sort ']' ) + ':' f=Expression;
AConjunction: fs=Disjunction (operator='&' fs=Disjunction)+;
ADisjunction: fs=Implication (operator='|' fs=Implication)+;
AImplication: fs=RImplication (operator='=>' fs=RImplication)+;
ARImplication: fs=Equivalence (operator='<=' fs=Equivalence)+;
AEquivalence: fs=Comparison (operator='<=>' fs=Comparison)+;
AComparison: fs=SumMinus (operator=ComparisonOp fs=SumMinus)+;
ASumMinus: fs=MultDiv (operator=SumMinusOp fs=MultDiv)+;
AMultDiv: fs=Unary (operator=MultDivOp fs=Unary)+;
AUnary: operator=UnaryOperator f=Base;

Base:  AppliedSymbol | Variable | NumberConstant | StringConstant | Brackets;

AppliedSymbol: s=Symbol args=Arguments;
Variable: name=ID;
NumberConstant: number=IDPFLOAT | number=INT;
StringConstant: str=STRING;
Brackets: '(' f=Expression ')';

Arguments: '(' fs*=Expression[','] ')';
SetExp: '{' (vars=ID '[' sorts=Sort ']')*  ':' f=Expression (':'  out=Expression)? '}';

Definition: '{' rules*=Rule '}';
Rule: ('!' (vars=ID '[' sorts=Sort ']')+ ':' )* symbol=Symbol args=Arguments? ('<-' body=Expression)? '.' ;

UnaryOperator: '-' | '~';
SumMinusOp: '+' | '-';
MultDivOp: '*' | '/';
ComparisonOp: '=<' | '>=' | '~=' | '=' | '<' | '>' ;
Quantor: '!' | '?';
AggType: '#' | 'card' | 'sum';

Declaration: ConstructedTypeDeclaration | RangeDeclaration | SymbolDeclaration;

ConstructedTypeDeclaration: 'type' name=ID 'constructed' 'from' '{' constructors*=ID[','] '}';
RangeDeclaration: 'type' name=ID '=' '{' elements*=RangeElement[','] '}';

RangeElement: fromI=NumberConstant ('..' to=NumberConstant)?;

SymbolDeclaration:
    name=Symbol ('(' args*=Sort[','] ')')? (':' out=Sort)?;

Sort: name=ID;
Symbol: name=ID;

IDPFLOAT: /[+-]?(\d+(\.\d+)?|\.\d+)/;
