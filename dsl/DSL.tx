File:
    vocabulary=Vocabulary
    theory=Theory
    structure=Structure?
;

Vocabulary: 'vocabulary' '{' (declarations=Declaration)* '}';

Theory: 'theory' '{' ((constraints=Expression '.')*  definitions=Definition*)* '}';

Structure: 'structure' '{' interpretations*=Interpretation '}';
Interpretation: name=Symbol '=' '{' tuples*=Tuple[';'] '}';
Tuple : args*=Base[','];

Comment:
  /\/\/.*$/
;

Expression: Quantification;

Quantification: AQuantification | RImplication;
RImplication: ARImplication | Equivalence;
Equivalence: AEquivalence | Implication;
Implication: AImplication | Disjunction;
Disjunction: ADisjunction | Conjunction;
Conjunction: AConjunction | Comparison;
Comparison: AComparison | SumMinus;
SumMinus: ASumMinus | MultDiv;
MultDiv: AMultDiv | Unary;
Unary: AUnary | Aggregate;
Aggregate: AAggregate | Base;


AAggregate: aggtype=AggType set=SetExp;
AQuantification: q=Quantor (vars=ID '[' sorts=Sort ']' ) + ':' f=Expression;
ARImplication: fs=Equivalence (operator='<=' fs=Equivalence)+;
AEquivalence: fs=Implication (operator='<=>' fs=Implication)+;
AImplication: fs=Disjunction (operator='=>' fs=Disjunction)+;
ADisjunction: fs=Conjunction (operator='|' fs=Conjunction)+;
AConjunction: fs=Comparison (operator='&' fs=Comparison)+;
AComparison: fs=SumMinus (operator=ComparisonOp fs=SumMinus)+;
ASumMinus: fs=MultDiv (operator=SumMinusOp fs=MultDiv)+;
AMultDiv: fs=Unary (operator=MultDivOp fs=Unary)+;
AUnary: operator=UnaryOperator f=Base;

Base:  AppliedSymbol | Variable | NumberConstant | StringConstant | Brackets;

AppliedSymbol: s=Symbol args=Arguments;
Variable: name=ID;
NumberConstant: number=IDPFLOAT | number=INT;
StringConstant: str=STRING;
Brackets: '(' f=Expression ')';

Arguments: '(' fs*=Expression[','] ')';
SetExp: '{' (vars=ID '[' sorts=Sort ']')*  ':' f=Expression (':'  out=Expression)? '}';

Definition: '{' rules*=Rule '}';
Rule: ('!' (vars=ID '[' sorts=Sort ']')+ ':' )* symbol=Symbol args=Arguments? ('=' out=Expression)? ('<-' body=Expression)? '.' ;

UnaryOperator: '-' | '~';
SumMinusOp: '+' | '-';
MultDivOp: '*' | '/';
ComparisonOp: '=<' | '>=' | '~=' | '=' | '<' !'-' | '>' | '≤' | '≥' | '≠' ;
Quantor: '∀' | '!' | '∃' | '?' ;
AggType: '#' | 'card' | 'sum';

Declaration: ConstructedTypeDeclaration | RangeDeclaration | SymbolDeclaration;

ConstructedTypeDeclaration: 'type' name=ID 'constructed' 'from' '{' constructors*=ID[','] '}';
RangeDeclaration: 'type' name=ID '=' '{' elements*=RangeElement[','] '}';

RangeElement: fromI=NumberConstant ('..' to=NumberConstant)?;

SymbolDeclaration:
    name=Symbol ('(' args*=Sort[','] ')')? (':' out=Sort)?;

Sort: name=ID;
Symbol: name=ID;

IDPFLOAT: /[+-]?(\d+(\.\d+)?|\.\d+)/;
