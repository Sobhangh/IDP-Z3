File:
    voc=Vocabulary
    theo=Theory
;

Vocabulary:
'vocabulary' '{' (declaration=Declaration '.')* '}'
;

Theory:
'theory' '{' (constraint=Expression '.')* '}'
;

Comment:
  /\/\/.*$/
;

Expression: Quantification;

Quantification: AQuantification | Conjunction;
Conjunction: AConjunction | Disjunction;
Disjunction: ADisjunction | Implication;
Implication: AImplication | RImplication;
RImplication: ARImplication | Equivalence;
Equivalence: AEquivalence | Comparison;
Comparison: AComparison | SumMinus;
SumMinus: ASumMinus | MultDiv;
MultDiv: AMultDiv | Unary;
Unary: AUnary | Base;

AQuantification: q=Quantor var=ID '[' sort=ID ']:' f=Conjunction;
AConjunction: fs=Disjunction (operator='&' fs=Disjunction)+;
ADisjunction: fs=Implication (operator='|' fs=Implication)+;
AImplication: fs=RImplication (operator='=>' fs=RImplication)+;
ARImplication: fs=Equivalence (operator='<=' fs=Equivalence)+;
AEquivalence: fs=Comparison (operator='<=>' fs=Comparison)+;
AComparison: fs=SumMinus (operator=ComparisonOp fs=SumMinus)+;
ASumMinus: fs=MultDiv (operator=SumMinusOp fs=MultDiv)+;
AMultDiv: fs=Unary (operator=MultDivOp fs=Unary)+;
AUnary: neg=UnaryOperator f=Base;

Base:  s=[Symbol] args=Arguments
      |var=ID
      |numb=NUMBER
      |str=STRING
      | '(' f=Expression ')';

Arguments: '(' fs*=Expression[','] ')';

UnaryOperator: '-' | '~';
SumMinusOp: '+' | '-';
MultDivOp: '*' | '/';
ComparisonOp: '=' | '<' | '>' | '=<' | '>=';
Quantor: '!' | '?';

Declaration: TypeDeclaration | SymbolDeclaration;

TypeDeclaration: 'type' name=ID 'constructed' 'from' '{' sorts*=ID[','] '}';

SymbolDeclaration:
    name=Symbol ('(' args*=ID[','] ')')? (':' out=ID)?;

Symbol: name=ID;

