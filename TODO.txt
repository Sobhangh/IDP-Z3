To do:
    Support for constructor functions (p.6 of the IDP3 manual)
        - grammar
        - generate list of constructors
        - transform occurrences in source code, using If() if variables
    Lexicographic, Pareto and conditional optimization
    Support for dates


Research topics / may take a while:
    Support for partial functions
    Support for partial interpretations (ct, cf, u) (p.17 of the IDP3 manual)
    Relevance
    Environmental vs Decision variables
    Support for non-linear equations


Of dubious benefit / may never be done:
    type enumeration in structure
    Type inference (p. 14 of the IDP3 manual)
    Support for type hierarchy
    Support for namespaces
    Support for strings
    Support for recursive definitions
    Support for multiple vocabulary / theories
    Support for natural (positive integers)
    Handling of division by 0 may differ (to be tested)
    Support order on domain elements (p. 8..9 )
    Support for LTC vocabulary
    Support for “quantified quantifiers”, and binary quantifications (p. 11 of the IDP3 manual)
    Support for aggregates on list of terms or formulas (p. 13 of the IDP3 manual)
    Support all syntactical forms of structures.
    Support for factlist (p. 17 of the IDP3 manual)
    Support of lua
    Abstract models:
        - show goal to the right of abstract models
        - join 2 disjuncts that differ only by the sign of one atom


other NTH (refactoring)
    - avoid quantifiers in definitions
    - do we need Expression.type, if we have Expression.decl ?
    - translate range declaration as comparisons for typeConstraints
    - distinguish between x=1 entry and x=1 atom in output structure
    - simplify Or, And with only one element
    - p(real) should be possible
    - client should send the literal to be explained, not the atom

