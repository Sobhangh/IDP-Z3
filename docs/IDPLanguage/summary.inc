

Syntax summary
--------------

The following code illustrates the syntax of IDP-Z3.
T denotes a type, c a constructor, p a proposition or predicate, f a constant or function.
The equivalent ASCII-only encoding is shown on the right.

.. code::

    vocabulary V {
        type T
        type T := {c1, c2, c3}
        type T := constructed from {c1, c2(T1, f:T2)}
        type T := {1,2,3}
        type T := {1..3}
        // built-in types: ğ”¹, â„¤, â„, Date, Symbol  Bool, Int, Real, Date, Symbol

        p : () â†’ ğ”¹                                p: () -> Bool
        p1, p2 : T1 â¨¯ T2 â†’ ğ”¹                      p1, p2: T1*T2 -> Bool
        f: T â†’ T                                  f: T -> T
        f1, f2: T â†’ T                             f1, f2: T -> T

        [this is the intended meaning of p]
        p : () â†’ ğ”¹

        extern vocabulary W
    }

    theory T:V {
        (Â¬p1()âˆ§p2() âˆ¨ p3() â‡’ p4() â‡” p5()) â‡ p6(). (~p1()&p2() | p3() => p4() <=> p5()) <= p6().
        p(f1(f2())).
        f1() < f2() â‰¤ f3() = f4() â‰¥ f5() > f6().  f1() < f2() =< f3() = f4() >= f5() > f6().
        f() â‰  c.                                  f() ~= c.
        âˆ€x,y âˆˆ T: p(x,y).                         !x,y in T: p(x,y).
        âˆ€x âˆˆ p, (y,z) âˆˆ q: q(x,x) âˆ¨ p(y) âˆ¨ p(z).  !x in p, (y,z) in q: q(x,x) | p(y) | p(z).
        âˆƒx âˆˆ Symbol: arity(x)=0 âˆ§ $(x)().         ?x in Symbol: arity(x)=0 & $(x)().
        âˆƒx âˆˆ $(input_domain(`p,1)): p(x).         ?x in $(input_domain(`p,1)): p(x).
        âˆƒx: p(x).                                 ?x: p(x).


        f() in {1,2,3}.
        f() = #{xâˆˆT: p(x)}.                       f() = #{x in T: p(x)}.
        f() = sum{xâˆˆT: p(x): f(x)}.               f() = sum{x in T: p(x): f(x)}.
        if p1() then p2() else p3().
        f1() = if p() then f2() else f3().

        p := {1,2,3}
        p(#2020-01-01) is enumerated.
        p(#TODAY) is not enumerated.

        { p(1).
          âˆ€xâˆˆT: p1(x) â† p2(x).                    !x in T: p1(x) <- p2(x).
          f(1)=1.
          âˆ€x: f(x)=1 â† p(x).                      !x: f(x)=1 <- p(x).
        }

        [this is the intended meaning of the rule]
        (p()).
    }

    structure S:V {
        p := false
        p := {1,2,3}
        p := {0..9, 100}
        p := {#2021-01-01}
        p := {(1,2), (3,4)}
        p := {
        1 2
        3 4
        }

        f := 1
        f := {â†’1}                                 f := {-> 1}
        f := {1â†’1, 2â†’2}                           f := {1->1, 2->2}
        f := {(1,2)â†’3} else 2                     f := {(1,2)->3} else 2
    }

    display {
        expand(`p).
        hide(`p).
        view() = expanded.
        relevant(`p1, `p2).
        goal(`p).
        optionalPropagation.
    }

    procedure main() {
        print(model_check    (T,S))
        print(model_expand   (T,S))
        print(model_propagate(T,S))
    }
