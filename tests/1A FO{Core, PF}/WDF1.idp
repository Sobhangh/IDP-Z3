vocabulary V {
    type color := {a, b}
    col : color -> Bool
    c: () -> color
    p: col -> Bool
    pp: p -> Bool
    i: col -> Int
    q : () -> Bool
    d: q -> Bool
}

theory T:V {
    p(a).
    col(a) & p(a).

    p(c()).
    col(c()) & p(c()).
    p(c()) & col(c()).
    col(c()).
    col(c()) => p(c()).
    col(c()) | p(c()).
    if col(c()) then p(c()) else true.
    ~col(c()) | p(c()).
    pp(c()).

    p($(`c)()).
    ?x in Concept[()->color]: p($(x)()).
    ?x in Concept[()->color]: col($(x)()) & p($(x)()).
    ?x in Concept[()->color]: col($(x)()) => p($(x)()).
    ?x in Concept[col -> Bool]: ? y in $(x): y=c().

    #{x in color: p(x)} = 2.
    #{x in color: col(x) & p(x)} = 2.
    min{i(x) | x in color: col(x) & p(x)} = 2.
    min{i(x) | x in color: p(x)} = 2.

    ? x in col: 0 < 4/i(x).
    ? x in col: i(x) ~= 0 & 0 < 4/i(x).

    d().
    q() & d().

    { !x in col: p(x).}
    { !x in color: p(x).}
}
procedure main() {
    Th = Theory(T)
    print("Formula: ")
    pretty_print(Th.formula())
    print("WDF: ")
    pretty_print(Th.WDFs)
}