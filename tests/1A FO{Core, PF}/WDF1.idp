vocabulary V {
    type color := {a, b}
    col : color -> Bool
    c: () -> color
    p: color -> Bool (p ⊆ col)
    pp: color -> Bool (pp ⊆ p)
    i: color -> Int (domain: pp)
    q : () -> Bool
    d: () -> Bool (d ⊆ q)
}

theory T:V {
    // predicates
    p(a).
    col(a) & p(a).
    p(c()).

    // function i
    i(c()) = 1.
    i(c()) = 1 & pp(c()).
    pp(c()) & i(c()) = 1.
    pp(c()) => i(c()) = 1.
    pp(c()) | i(c()) = 1.
    ~pp(c()) | i(c()) = 1.
    if pp(c()) then i(c()) = 1 else true.

    // concepts
    i($(`c)())=1.
    ?x in Concept[pp->Int]: $(x)(a) = 1.
    ?x in Concept[pp->Int]: pp(a) & $(x)(a) = 1.

    ?x in Concept[()->color]: p($(x)()).
    ?x in Concept[()->color]: col($(x)()) & p($(x)()).
    ?x in Concept[()->color]: col($(x)()) => p($(x)()).
    ?x in Concept[color -> Bool]: ? y in $(x): y=c().

    #{x in color: p(x)} = 2.
    #{x in color: col(x) & p(x)} = 2.
    min{i(x) | x in color: col(x) & p(x)} = 2.
    min{i(x) | x in color: p(x)} = 2.

    ? x in col: 0 < 4/i(x).
    ? x in col: i(x) ~= 0 & 0 < 4/i(x).

    d().
    q() & d().

}
procedure main() {
    Th = Theory(T)
    print("Formula: ")
    pretty_print(Th.formula())
    print("WDF: ")
    pretty_print(Th.WDFs)
}